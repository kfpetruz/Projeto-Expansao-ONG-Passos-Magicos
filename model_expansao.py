# -*- coding: utf-8 -*-
"""model_expansao.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Kf-OfHpAUYAgeAgcZWji22Yu6c6A-paC

# Bibliotecas
"""

import pandas as pd
import numpy as np

# Plot dos gráficos
import matplotlib.pyplot as plt
from matplotlib import colors
import seaborn as sns

#Feature Engineer
from sklearn.preprocessing import StandardScaler, MinMaxScaler

# Algoritmo de Agrupamento
from sklearn.cluster import KMeans

# Avaliacao de desemepnho
from sklearn.metrics import adjusted_rand_score, silhouette_score

# Para processar arquivos e imagens
#from PIL import Image
#import glob

# Para plotar imagens
#import matplotlib.image as mpimg

dados_pede = pd.read_excel('tb_pesquisa_desenvolvimento_educacional_passos.xlsx')
dados_pede.head()

dados_externos = pd.read_excel('tb_populacao_economia_idade_distancia.xlsx')
dados_externos.head()

dados_externos['percent_elegiveis_6a19a'] = dados_externos['Pessoas de 6 a 19 anos'] / dados_externos['População no último censo'] * 100
dados_externos['Matriculados/População 6 a 19'] = dados_externos['Matriculados/População 6 a 19'] * 100
dados_externos.head()

dados_externos = dados_externos[['Município', 'Salário médio mensal dos trabalhadores formais', 'PIB per capita', 'População no último censo', 'Densidade demográfica habitante/km²', 'Distância', 'Matriculados/População 6 a 19', 'percent_elegiveis_6a19a']]
dados_externos = dados_externos.rename(columns= {'Município': 'municipio', 'Salário médio mensal dos trabalhadores formais': 'salario_medio_trabalhadores', 'PIB per capita': 'pib_per_capita', 'Área da unidade territorial': 'area_territorial', 'População no último censo': 'populacao', 'Densidade demográfica habitante/km²': 'densidade_demografica_km2', 'Distância': 'distancia_de_embu_guacu', 'Matriculados/População 6 a 19': 'percent_matriculados_6a19a'})
dados_externos.head()

dados_externos.shape

dados_externos.info()

dados_externos.describe()

dados_externos.sort_values(by='pib_per_capita', ascending=False).head()

"""## Backup DataFrame"""

dados_externos_bkp = dados_externos

dados_externos_bkp.head()

"""# Modelo matemático"""

dados_model_math = dados_externos[['municipio', 'salario_medio_trabalhadores', 'pib_per_capita', 'densidade_demografica_km2', 'distancia_de_embu_guacu', 'percent_matriculados_6a19a', 'percent_elegiveis_6a19a']]
dados_model_math.head()

# Normalizandos os dados
variaveis_normalizar = ['densidade_demografica_km2', 'percent_elegiveis_6a19a']

variaveis_normalizar_inversamente = ['salario_medio_trabalhadores','pib_per_capita', 'distancia_de_embu_guacu', 'percent_matriculados_6a19a']

# Normalização
scaler = MinMaxScaler()
dados_model_math[variaveis_normalizar] = scaler.fit_transform(dados_model_math[variaveis_normalizar])

# Normalização inversa
scaler = MinMaxScaler()
dados_model_math[variaveis_normalizar_inversamente] = 1 - scaler.fit_transform(dados_model_math[variaveis_normalizar_inversamente])

dados_model_math.head()

#DEIXAR VARIÁVEIS DINAMICAS NO STREAMLIT
# Pesos
prioridade_distancia_embu = 6
prioridade_salario_medio = 5
prioridade_pib_per_capita = 4
prioridade_percent_idade_elegivel = 3
prioridade_percent_matriculados = 2
prioridade_densidade_demografica = 1

# Atribuição de pesos
dados_model_math['distancia_de_embu_guacu'] = prioridade_distancia_embu * dados_model_math['distancia_de_embu_guacu']
dados_model_math['salario_medio_trabalhadores'] = prioridade_salario_medio * dados_model_math['salario_medio_trabalhadores']
dados_model_math['pib_per_capita'] = prioridade_pib_per_capita * dados_model_math['pib_per_capita']
dados_model_math['percent_elegiveis_6a19a'] = prioridade_percent_idade_elegivel * dados_model_math['percent_elegiveis_6a19a']
dados_model_math['percent_matriculados_6a19a'] = prioridade_percent_matriculados * dados_model_math['percent_matriculados_6a19a']
dados_model_math['densidade_demografica_km2'] = prioridade_densidade_demografica * dados_model_math['densidade_demografica_km2']


# Soma ponderada
dados_model_math['soma_ponderada'] = dados_model_math[['distancia_de_embu_guacu', 'salario_medio_trabalhadores', 'pib_per_capita', 'percent_elegiveis_6a19a', 'percent_matriculados_6a19a', 'densidade_demografica_km2']].sum(axis=1)

# Classificar o DataFrame com base na soma ponderada
dados_model_math = dados_model_math.sort_values(by='soma_ponderada', ascending=False)

# Visualizando o DataFrame classificado
dados_model_math.head(10)

dados_model_math.describe()

dados_externos.iloc[121]

dados_externos.iloc[412]

dados_externos_model_math = pd.merge(dados_externos, dados_model_math[['municipio', 'soma_ponderada']], on='municipio', how='left')
dados_externos_model_math.head()

dados_externos_model_math = dados_externos_model_math.sort_values('soma_ponderada', ascending = False)
dados_externos_model_math.head(10)

"""# K-Means"""

dados_model_kmeans = dados_model_math.drop('soma_ponderada', axis = 1)
dados_model_kmeans.head()

dados_model_kmeans.shape

dados_model_kmeans.info()

#variaveis_preditoras = ['Salário médio mensal dos trabalhadores formais', 'Índice de Desenvolvimento Humano Municipal (IDHM)', 'PIB per capita', 'População no último censo', 'Densidade demográfica habitante/km²', 'Pessoas em idade elegível']
# variaveis_preditoras = ['Salário médio mensal dos trabalhadores formais', 'Índice de Desenvolvimento Humano Municipal (IDHM)']
# num_clusters = 8
# kmeans = KMeans(n_clusters=num_clusters, random_state=42)
# dados_classificados_kmeans['cluster'] = kmeans.fit_predict(dados_classificados_kmeans[variaveis_preditoras])

# Definindo o modelo de clusterizacao. K-MEANS com 6 clusters
kmeans = KMeans(n_clusters=8,random_state=0) #definindo os hiperparametros do algoritmo (definir o número de grupo = cluster)

#Implementando o K-Means nos dados:
kmeans.fit(dados_model_kmeans[['distancia_de_embu_guacu', 'salario_medio_trabalhadores', 'pib_per_capita', 'percent_elegiveis_6a19a', 'percent_matriculados_6a19a', 'densidade_demografica_km2']])

#Salvando os centroides de cada cluster
centroides = kmeans.cluster_centers_

#Salvando os labels dos clusters para cada exemplo
kmeans_labels = kmeans.predict(dados_model_kmeans[['distancia_de_embu_guacu', 'salario_medio_trabalhadores', 'pib_per_capita', 'percent_elegiveis_6a19a', 'percent_matriculados_6a19a', 'densidade_demografica_km2']])

dados_model_kmeans['grupos'] = kmeans_labels
dados_model_kmeans.head()

pd.Series(kmeans_labels).value_counts()

dados_externos_order_math = dados_externos_model_math.drop('soma_ponderada', axis = 1)
dados_externos_order_math.head()

dados_externos_model_kmeans = pd.merge(dados_externos_order_math, dados_model_kmeans[['municipio', 'grupos']], on='municipio', how='left')
dados_externos_model_kmeans.head(10)



import matplotlib.pyplot as plt

# Plotando os dados identificando com os seus clusters
plt.scatter(dados_model_kmeans['distancia_de_embu_guacu'],
            dados_model_kmeans['salario_medio_trabalhadores'],
            c=kmeans_labels,
            alpha=0.5,
            cmap='rainbow')

# Plotando os centroides
plt.scatter(centroides[:, 0],
            centroides[:, 1],
            c='black',
            marker='X',
            s=200,
            alpha=0.5)

plt.xlabel('Distância de Embu Guaçu')
plt.ylabel('Salário Médio dos Trabalhadores')
plt.title('Clusters Identificados')
plt.rcParams['figure.figsize'] = (10, 5)
plt.show()

import matplotlib.pyplot as plt

# Criando a figura
fig = plt.figure()

# Plotando os dados identificando com os seus clusters
plt.scatter(dados_model_kmeans['distancia_de_embu_guacu'],
            dados_model_kmeans['salario_medio_trabalhadores'],
            c=kmeans_labels,
            alpha=0.5,
            cmap='rainbow')

# Plotando os centroides
plt.scatter(centroides[:, 0],
            centroides[:, 1],
            c='black',
            marker='X',
            s=200,
            alpha=0.5)

plt.xlabel('Distância de Embu Guaçu')
plt.ylabel('Salário Médio dos Trabalhadores')
plt.title('Clusters Identificados')
plt.rcParams['figure.figsize'] = (10, 5)

# Definindo a cor de fundo
fig.patch.set_facecolor('#F2F2F2')

plt.show()